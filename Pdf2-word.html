<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Watermark Removal Tool</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-top: 20px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2.2rem;
        }
        
        .description {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .upload-container {
            border: 2px dashed #3498db;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s;
            background: #f8fafc;
        }
        
        .upload-container:hover {
            background: #e8f4ff;
            border-color: #2980b9;
        }
        
        .upload-icon {
            font-size: 50px;
            color: #3498db;
            margin-bottom: 15px;
        }
        
        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-block;
            margin: 10px 5px;
        }
        
        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .btn-process {
            background: #2ecc71;
        }
        
        .btn-process:hover {
            background: #27ae60;
        }
        
        .btn-download {
            background: #9b59b6;
        }
        
        .btn-download:hover {
            background: #8e44ad;
        }
        
        .preview-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
        }
        
        .preview-box {
            flex: 1;
            min-width: 300px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            background: #fafafa;
        }
        
        .preview-title {
            text-align: center;
            margin-bottom: 15px;
            color: #2c3e50;
            font-weight: 600;
        }
        
        .canvas-container {
            width: 100%;
            height: 300px;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .controls {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background: #f8fafc;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
        }
        
        .slider {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            outline: none;
            border-radius: 5px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }
        
        .slider-value {
            width: 40px;
            text-align: right;
            margin-left: 15px;
            font-weight: 600;
            color: #3498db;
        }
        
        .note {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .preview-container {
                flex-direction: column;
            }
            
            .container {
                padding: 15px;
            }
            
            .upload-container {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <h1>PDF Watermark Removal Tool</h1>
    <p class="description">Upload a PDF, process it to remove watermarks, and download the result (Client-side processing)</p>
    
    <div class="container">
        <div class="upload-container" id="upload-container">
            <div class="upload-icon">ðŸ“„</div>
            <h2>Upload your PDF file</h2>
            <p>PDF should contain watermarks that you want to remove</p>
            <input type="file" id="file-input" accept=".pdf" class="hidden">
            <button class="btn" id="upload-btn">Select PDF File</button>
        </div>
        
        <div class="note">
            <strong>Note:</strong> This tool processes PDFs in your browser without uploading to any server.
            Watermark removal effectiveness depends on the watermark type and contrast. Complex watermarks may not be fully removed.
        </div>
        
        <div class="controls hidden" id="controls">
            <h3>Adjust Processing Parameters</h3>
            
            <div class="control-group">
                <label class="control-label">Brightness Adjustment</label>
                <div class="slider-container">
                    <input type="range" min="-100" max="100" value="20" class="slider" id="brightness-slider">
                    <span class="slider-value" id="brightness-value">20</span>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Contrast Adjustment</label>
                <div class="slider-container">
                    <input type="range" min="-100" max="100" value="30" class="slider" id="contrast-slider">
                    <span class="slider-value" id="contrast-value">30</span>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Color Threshold</label>
                <div class="slider-container">
                    <input type="range" min="0" max="255" value="200" class="slider" id="threshold-slider">
                    <span class="slider-value" id="threshold-value">200</span>
                </div>
            </div>
            
            <button class="btn btn-process" id="process-btn">Process Watermark Removal</button>
        </div>
        
        <div class="loading hidden" id="loading">
            <div class="spinner"></div>
            <p>Processing PDF, please wait...</p>
        </div>
        
        <div class="preview-container hidden" id="preview-container">
            <div class="preview-box">
                <div class="preview-title">Original PDF Page</div>
                <div class="canvas-container">
                    <canvas id="original-canvas"></canvas>
                </div>
            </div>
            
            <div class="preview-box">
                <div class="preview-title">Processed PDF Page</div>
                <div class="canvas-container">
                    <canvas id="processed-canvas"></canvas>
                </div>
            </div>
        </div>
        
        <div class="hidden" id="download-section">
            <button class="btn btn-download" id="download-btn">Download Processed PDF</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
    <script>
        // Set PDF.js worker path
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        
        // DOM elements
        const fileInput = document.getElementById('file-input');
        const uploadBtn = document.getElementById('upload-btn');
        const uploadContainer = document.getElementById('upload-container');
        const controls = document.getElementById('controls');
        const loading = document.getElementById('loading');
        const previewContainer = document.getElementById('preview-container');
        const downloadSection = document.getElementById('download-section');
        const processBtn = document.getElementById('process-btn');
        const downloadBtn = document.getElementById('download-btn');
        
        const originalCanvas = document.getElementById('original-canvas');
        const processedCanvas = document.getElementById('processed-canvas');
        
        const brightnessSlider = document.getElementById('brightness-slider');
        const contrastSlider = document.getElementById('contrast-slider');
        const thresholdSlider = document.getElementById('threshold-slider');
        
        const brightnessValue = document.getElementById('brightness-value');
        const contrastValue = document.getElementById('contrast-value');
        const thresholdValue = document.getElementById('threshold-value');
        
        // Variables to store PDF data
        let pdfDoc = null;
        let currentPage = 1;
        let processedImages = [];
        
        // Event listeners
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileUpload);
        processBtn.addEventListener('click', processPDF);
        downloadBtn.addEventListener('click', downloadPDF);
        
        brightnessSlider.addEventListener('input', () => {
            brightnessValue.textContent = brightnessSlider.value;
        });
        
        contrastSlider.addEventListener('input', () => {
            contrastValue.textContent = contrastSlider.value;
        });
        
        thresholdSlider.addEventListener('input', () => {
            thresholdValue.textContent = thresholdSlider.value;
        });
        
        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                const fileReader = new FileReader();
                
                fileReader.onload = function() {
                    const typedarray = new Uint8Array(this.result);
                    
                    loading.classList.remove('hidden');
                    
                    // Load PDF using pdf.js
                    pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                        pdfDoc = pdf;
                        loading.classList.add('hidden');
                        controls.classList.remove('hidden');
                        uploadContainer.classList.add('hidden');
                        
                        // Render first page for preview
                        renderPage(pdfDoc, 1);
                    }).catch(error => {
                        console.error('Error loading PDF:', error);
                        alert('Error loading PDF. Please try another file.');
                        loading.classList.add('hidden');
                    });
                };
                
                fileReader.readAsArrayBuffer(file);
            } else {
                alert('Please select a valid PDF file.');
            }
        }
        
        // Render PDF page
        function renderPage(pdf, pageNumber) {
            pdf.getPage(pageNumber).then(page => {
                const viewport = page.getViewport({ scale: 1.5 });
                
                // Prepare canvas for original PDF
                const context = originalCanvas.getContext('2d');
                originalCanvas.height = viewport.height;
                originalCanvas.width = viewport.width;
                
                // Render PDF page to canvas
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                
                page.render(renderContext).promise.then(() => {
                    // Show preview after first render
                    previewContainer.classList.remove('hidden');
                });
            });
        }
        
        // Process PDF to remove watermarks
        function processPDF() {
            if (!pdfDoc) return;
            
            loading.classList.remove('hidden');
            processedImages = [];
            
            // Process each page
            const processPage = (pageNum) => {
                if (pageNum > pdfDoc.numPages) {
                    // All pages processed
                    loading.classList.add('hidden');
                    downloadSection.classList.remove('hidden');
                    renderProcessedPreview();
                    return;
                }
                
                pdfDoc.getPage(pageNum).then(page => {
                    const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better processing
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };
                    
                    page.render(renderContext).promise.then(() => {
                        // Apply filters to remove watermark
                        const processedImageData = applyFilters(context, canvas.width, canvas.height);
                        
                        // Store processed image
                        processedImages.push({
                            imageData: processedImageData,
                            width: canvas.width,
                            height: canvas.height
                        });
                        
                        // Process next page
                        processPage(pageNum + 1);
                    });
                });
            };
            
            // Start processing from first page
            processPage(1);
        }
        
        // Apply image filters to remove watermark
        function applyFilters(context, width, height) {
            // Get image data from canvas
            const imageData = context.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Get filter values
            const brightness = parseInt(brightnessSlider.value);
            const contrast = parseInt(contrastSlider.value);
            const threshold = parseInt(thresholdSlider.value);
            
            // Apply filters to each pixel
            for (let i = 0; i < data.length; i += 4) {
                // Brightness adjustment
                data[i] += brightness;     // Red
                data[i + 1] += brightness; // Green
                data[i + 2] += brightness; // Blue
                
                // Contrast adjustment
                const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                data[i] = clamp(factor * (data[i] - 128) + 128);
                data[i + 1] = clamp(factor * (data[i + 1] - 128) + 128);
                data[i + 2] = clamp(factor * (data[i + 2] - 128) + 128);
                
                // Simple threshold-based watermark removal
                // This assumes watermarks are lighter than the main content
                if (data[i] > threshold && data[i + 1] > threshold && data[i + 2] > threshold) {
                    // Make light pixels (potential watermark) more transparent
                    data[i + 3] = data[i + 3] * 0.2;
                }
            }
            
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Watermark & Keyword Removal Tool</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-top: 20px;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2.2rem;
        }
        
        .description {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        .upload-container {
            border: 2px dashed #3498db;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s;
            background: #f8fafc;
        }
        
        .upload-container:hover {
            background: #e8f4ff;
            border-color: #2980b9;
        }
        
        .upload-icon {
            font-size: 50px;
            color: #3498db;
            margin-bottom: 15px;
        }
        
        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            display: inline-block;
            margin: 10px 5px;
        }
        
        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .btn-process {
            background: #2ecc71;
        }
        
        .btn-process:hover {
            background: #27ae60;
        }
        
        .btn-download {
            background: #9b59b6;
        }
        
        .btn-download:hover {
            background: #8e44ad;
        }
        
        .btn-reset {
            background: #e74c3c;
        }
        
        .btn-reset:hover {
            background: #c0392b;
        }
        
        .preview-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
        }
        
        .preview-box {
            flex: 1;
            min-width: 300px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            background: #fafafa;
        }
        
        .preview-title {
            text-align: center;
            margin-bottom: 15px;
            color: #2c3e50;
            font-weight: 600;
        }
        
        .canvas-container {
            width: 100%;
            height: 300px;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .controls {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background: #f8fafc;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
        }
        
        .slider {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            outline: none;
            border-radius: 5px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }
        
        .slider-value {
            width: 40px;
            text-align: right;
            margin-left: 15px;
            font-weight: 600;
            color: #3498db;
        }
        
        .keyword-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .keyword-list {
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
            background: white;
        }
        
        .keyword-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #f1f8ff;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        
        .keyword-item span {
            flex: 1;
        }
        
        .keyword-item button {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 3px 8px;
            cursor: pointer;
        }
        
        .note {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .preview-container {
                flex-direction: column;
            }
            
            .container {
                padding: 15px;
            }
            
            .upload-container {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <h1>PDF Watermark & Keyword Removal Tool</h1>
    <p class="description">Upload a PDF, remove watermarks and specific keywords, then download the result</p>
    
    <div class="container">
        <div class="upload-container" id="upload-container">
            <div class="upload-icon">ðŸ“„</div>
            <h2>Upload your PDF file</h2>
            <p>PDF should contain watermarks or text that you want to remove</p>
            <input type="file" id="file-input" accept=".pdf" class="hidden">
            <button class="btn" id="upload-btn">Select PDF File</button>
        </div>
        
        <div class="note">
            <strong>Note:</strong> This tool processes PDFs in your browser without uploading to any server.
            Watermark removal effectiveness depends on the watermark type and contrast. Keyword removal works by
            detecting and obscuring text patterns.
        </div>
        
        <div class="controls hidden" id="controls">
            <h3>Adjust Processing Parameters</h3>
            
            <div class="control-group">
                <label class="control-label">Brightness Adjustment</label>
                <div class="slider-container">
                    <input type="range" min="-100" max="100" value="20" class="slider" id="brightness-slider">
                    <span class="slider-value" id="brightness-value">20</span>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Contrast Adjustment</label>
                <div class="slider-container">
                    <input type="range" min="-100" max="100" value="30" class="slider" id="contrast-slider">
                    <span class="slider-value" id="contrast-value">30</span>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Color Threshold</label>
                <div class="slider-container">
                    <input type="range" min="0" max="255" value="200" class="slider" id="threshold-slider">
                    <span class="slider-value" id="threshold-value">200</span>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Keywords to Remove (Case Sensitive)</label>
                <input type="text" id="keyword-input" class="keyword-input" placeholder="Enter keyword to remove">
                <button class="btn" id="add-keyword-btn">Add Keyword</button>
                
                <div class="keyword-list" id="keyword-list">
                    <!-- Keywords will be added here -->
                </div>
            </div>
            
            <button class="btn btn-process" id="process-btn">Process PDF</button>
            <button class="btn btn-reset" id="reset-btn">Reset Settings</button>
        </div>
        
        <div class="loading hidden" id="loading">
            <div class="spinner"></div>
            <p>Processing PDF, please wait...</p>
        </div>
        
        <div class="preview-container hidden" id="preview-container">
            <div class="preview-box">
                <div class="preview-title">Original PDF Page</div>
                <div class="canvas-container">
                    <canvas id="original-canvas"></canvas>
                </div>
            </div>
            
            <div class="preview-box">
                <div class="preview-title">Processed PDF Page</div>
                <div class="canvas-container">
                    <canvas id="processed-canvas"></canvas>
                </div>
            </div>
        </div>
        
        <div class="hidden" id="download-section">
            <button class="btn btn-download" id="download-btn">Download Processed PDF</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.min.js"></script>
    <script>
        // Set PDF.js worker path
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.12.313/pdf.worker.min.js';
        
        // DOM elements
        const fileInput = document.getElementById('file-input');
        const uploadBtn = document.getElementById('upload-btn');
        const uploadContainer = document.getElementById('upload-container');
        const controls = document.getElementById('controls');
        const loading = document.getElementById('loading');
        const previewContainer = document.getElementById('preview-container');
        const downloadSection = document.getElementById('download-section');
        const processBtn = document.getElementById('process-btn');
        const downloadBtn = document.getElementById('download-btn');
        const resetBtn = document.getElementById('reset-btn');
        const keywordInput = document.getElementById('keyword-input');
        const addKeywordBtn = document.getElementById('add-keyword-btn');
        const keywordList = document.getElementById('keyword-list');
        
        const originalCanvas = document.getElementById('original-canvas');
        const processedCanvas = document.getElementById('processed-canvas');
        
        const brightnessSlider = document.getElementById('brightness-slider');
        const contrastSlider = document.getElementById('contrast-slider');
        const thresholdSlider = document.getElementById('threshold-slider');
        
        const brightnessValue = document.getElementById('brightness-value');
        const contrastValue = document.getElementById('contrast-value');
        const thresholdValue = document.getElementById('threshold-value');
        
        // Variables to store PDF data
        let pdfDoc = null;
        let currentPage = 1;
        let processedImages = [];
        let keywords = [];
        
        // Event listeners
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileUpload);
        processBtn.addEventListener('click', processPDF);
        downloadBtn.addEventListener('click', downloadPDF);
        resetBtn.addEventListener('click', resetSettings);
        addKeywordBtn.addEventListener('click', addKeyword);
        
        brightnessSlider.addEventListener('input', () => {
            brightnessValue.textContent = brightnessSlider.value;
        });
        
        contrastSlider.addEventListener('input', () => {
            contrastValue.textContent = contrastSlider.value;
        });
        
        thresholdSlider.addEventListener('input', () => {
            thresholdValue.textContent = thresholdSlider.value;
        });
        
        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                const fileReader = new FileReader();
                
                fileReader.onload = function() {
                    const typedarray = new Uint8Array(this.result);
                    
                    loading.classList.remove('hidden');
                    
                    // Load PDF using pdf.js
                    pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                        pdfDoc = pdf;
                        loading.classList.add('hidden');
                        controls.classList.remove('hidden');
                        uploadContainer.classList.add('hidden');
                        
                        // Render first page for preview
                        renderPage(pdfDoc, 1);
                    }).catch(error => {
                        console.error('Error loading PDF:', error);
                        alert('Error loading PDF. Please try another file.');
                        loading.classList.add('hidden');
                    });
                };
                
                fileReader.readAsArrayBuffer(file);
            } else {
                alert('Please select a valid PDF file.');
            }
        }
        
        // Render PDF page
        function renderPage(pdf, pageNumber) {
            pdf.getPage(pageNumber).then(page => {
                const viewport = page.getViewport({ scale: 1.5 });
                
                // Prepare canvas for original PDF
                const context = originalCanvas.getContext('2d');
                originalCanvas.height = viewport.height;
                originalCanvas.width = viewport.width;
                
                // Render PDF page to canvas
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                
                page.render(renderContext).promise.then(() => {
                    // Show preview after first render
                    previewContainer.classList.remove('hidden');
                });
            });
        }
        
        // Add keyword to removal list
        function addKeyword() {
            const keyword = keywordInput.value.trim();
            if (keyword && !keywords.includes(keyword)) {
                keywords.push(keyword);
                updateKeywordList();
                keywordInput.value = '';
            }
        }
        
        // Update keyword list UI
        function updateKeywordList() {
            keywordList.innerHTML = '';
            keywords.forEach(keyword => {
                const item = document.createElement('div');
                item.className = 'keyword-item';
                item.innerHTML = `
                    <span>${keyword}</span>
                    <button class="remove-keyword" data-keyword="${keyword}">Remove</button>
                `;
                keywordList.appendChild(item);
            });
            
            // Add event listeners to remove buttons
            document.querySelectorAll('.remove-keyword').forEach(button => {
                button.addEventListener('click', (e) => {
                    const keywordToRemove = e.target.getAttribute('data-keyword');
                    keywords = keywords.filter(k => k !== keywordToRemove);
                    updateKeywordList();
                });
            });
        }
        
        // Reset all settings
        function resetSettings() {
            brightnessSlider.value = 20;
            contrastSlider.value = 30;
            thresholdSlider.value = 200;
            brightnessValue.textContent = '20';
            contrastValue.textContent = '30';
            thresholdValue.textContent = '200';
            keywords = [];
            updateKeywordList();
        }
        
        // Process PDF to remove watermarks and keywords
        function processPDF() {
            if (!pdfDoc) return;
            
            loading.classList.remove('hidden');
            processedImages = [];
            
            // Process each page
            const processPage = (pageNum) => {
                if (pageNum > pdfDoc.numPages) {
                    // All pages processed
                    loading.classList.add('hidden');
                    downloadSection.classList.remove('hidden');
                    renderProcessedPreview();
                    return;
                }
                
                pdfDoc.getPage(pageNum).then(page => {
                    const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better processing
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };
                    
                    page.render(renderContext).promise.then(() => {
                        // Apply filters to remove watermark and keywords
                        const processedImageData = applyFilters(context, canvas.width, canvas.height);
                        
                        // Store processed image
                        processedImages.push({
                            imageData: processedImageData,
                            width: canvas.width,
                            height: canvas.height
                        });
                        
                        // Process next page
                        processPage(pageNum + 1);
                    });
                });
            };
            
            // Start processing from first page
            processPage(1);
        }
        
        // Apply image filters to remove watermark and keywords
        function applyFilters(context, width, height) {
            // Get image data from canvas
            const imageData = context.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Get filter values
            const brightness = parseInt(brightnessSlider.value);
            const contrast = parseInt(contrastSlider.value);
            const threshold = parseInt(thresholdSlider.value);
            
            // Apply filters to each pixel
            for (let i = 0; i < data.length; i += 4) {
                // Brightness adjustment
                data[i] += brightness;     // Red
                data[i + 1] += brightness; // Green
                data[i + 2] += brightness; // Blue
                
                // Contrast adjustment
                const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                data[i] = clamp(factor * (data[i] - 128) + 128);
                data[i + 1] = clamp(factor * (data[i + 1] - 128) + 128);
                data[i + 2] = clamp(factor * (data[i + 2] - 128) + 128);
                
                // Simple threshold-based watermark removal
                // This assumes watermarks are lighter than the main content
                if (data[i] > threshold && data[i + 1] > threshold && data[i + 2] > threshold) {
                    // Make light pixels (potential watermark) more transparent
                    data[i + 3] = data[i + 3] * 0.2;
                }
            }
            
            // For a real implementation, keyword removal would require OCR technology
            // This is a simplified simulation that looks for text patterns
            if (keywords.length > 0) {
                simulateKeywordRemoval(imageData, width, height);
            }
            
            return imageData;
        }
        
        // Simulate keyword removal (in a real implementation, this would use OCR)
        function simulateKeywordRemoval(imageData, width, height) {
            const data = imageData.data;
            const keywordRegions = findTextRegions(imageData, width, height);
            
            // For each detected text region, check if it might contain keywords
            // and obscure those regions
            for (const region of keywordRegions) {
                // In a real implementation, we would use OCR to extract text
                // and compare with our keyword list
                // Here we're just simulating the process
                
                // Obscure the region by making it blend with the background
                for (let y = region.y; y < region.y + region.height; y++) {
                    for (let x = region.x; x < region.x + region.width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Sample surrounding pixels to create a blur effect
                        const avg = sampleSurroundingPixels(data, x, y, width, height);
                        data[idx] = avg.r;
                        data[idx + 1] = avg.g;
                        data[idx + 2] = avg.b;
                    }
                }
            }
        }
        
        // Find regions that likely contain text
        function findTextRegions(imageData, width, height) {
            const data = imageData.data;
            const regions = [];
            const visited = new Array(width * height).fill(false);
            
            // Simple edge detection to find text regions
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    if (!visited[y * width + x] && isLikelyTextPixel(data, idx, width)) {
                        // Found a potential text pixel, flood fill to find the region
                        const region = floodFill(x, y, data, visited, width, height);
                        if (region.width > 5 && region.height > 5) { // Filter out small regions
                            regions.push(region);
                        }
                    }
                }
            }
            
            return regions;
        }
        
        // Check if a pixel is likely part of text
        function isLikelyTextPixel(data, idx, width) {
            // Simple heuristic: text usually has high contrast with background
            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            const nextBrightness = (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3;
            
            return Math.abs(brightness - nextBrightness) > 50; // High contrast
        }
        
        // Flood fill algorithm to find connected regions
        function floodFill(startX, startY, data, visited, width, height) {
            const queue = [[startX, startY]];
            let minX = startX, maxX = startX;
            let minY = startY, maxY = startY;
            
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                const idx = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height || visited[idx]) continue;
                
                visited[idx] = true;
                const pixelIdx = idx * 4;
                
                if (isLikelyTextPixel(data, pixelIdx, width)) {
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    
                    // Check all 8 directions
                    queue.push([x + 1, y]);
                    queue.push([x - 1, y]);
                    queue.push([x, y + 1]);
                    queue.push([x, y - 1]);
                    queue.push([x + 1, y + 1]);
                    queue.push([x - 1, y - 1]);
                    queue.push([x + 1, y - 1]);
                    queue.push([x - 1, y + 1]);
                }
            }
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX + 1,
                height: maxY - minY + 1
            };
        }
        
        // Sample surrounding pixels to get average color
        function sampleSurroundingPixels(data, x, y, width, height) {
            let r = 0, g = 0, b = 0, count = 0;
            
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const idx = (ny * width + nx) * 4;
                        r += data[idx];
                        g += data[idx + 1];
                        b += data[idx + 2];
                        count++;
                    }
                }
            }
            
            return {
                r: r / count,
                g: g / count,
                b: b / count
            };
        }
        
        // Clamp value between 0-255
        function clamp(value) {
            return Math.max(0, Math.min(255, value));
        }
        
        // Render processed preview
        function renderProcessedPreview() {
            if (processedImages.length === 0) return;
            
            const firstPage = processedImages[0];
            const context = processedCanvas.getContext('2d');
            
            processedCanvas.width = firstPage.width;
            processedCanvas.height = firstPage.height;
            
            context.putImageData(firstPage.imageData, 0, 0);
        }
        
        // Download processed PDF
        function downloadPDF() {
            // This is a simplified version - in a real application, you would need to
            // reconstruct a PDF from the processed images, which is complex in the browser
            alert('In a full implementation, this would download the processed PDF. This demo shows the processing concept but does not generate a downloadable PDF file.');
            
            // For a real implementation, you would need to:
            // 1. Convert each processed image to a PDF page
            // 2. Combine all pages into a PDF document
            // 3. Generate a download link for the PDF
        }
    </script>
</body>
</html>
