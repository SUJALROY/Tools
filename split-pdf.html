<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Next Move Analyzer with Checkmate Focus</title>
    <!-- Chessboard.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/chessboard-js@1.0.0/dist/chessboard-1.0.0.min.css">
    <!-- OpenCV.js for potential board recognition -->
    <script async src="https://docs.opencv.org/4.5.5/opencv.js" onload="onOpenCvReady()"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
            background-color: #f0f0f0;
            color: #333;
        }
        #chessboard {
            width: 90%;
            max-width: 400px;
            margin: 20px auto;
            border: 2px solid #333;
            border-radius: 8px;
        }
        #screen-feed {
            width: 90%;
            max-width: 400px;
            margin: 20px auto;
            border: 2px solid #333;
            border-radius: 8px;
            display: none;
        }
        #move-suggestion {
            margin: 20px auto;
            width: 90%;
            max-width: 400px; 
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 16px;
            color: #2e7d32;
            text-align: left;
        }
        #status {
            margin-top: 10px;
            font-size: 16px;
            color: #d81b60;
        }
        #move-history {
            margin: 20px auto;
            width: 90%;
            max-width: 400px;
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: left;
            max-height: 150px;
            overflow-y: auto;
            font-size: 14px;
        }
        .button-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #fen-input {
            margin: 10px auto;
            padding: 8px;
            width: 80%;
            max-width: 400px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 14px;
        }
        .loading {
            display: none;
            font-size: 14px;
            color: #0288d1;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Chess Next Move Analyzer</h1>
    <div id="chessboard"></div>
    <div class="button-container">
        <button onclick="startScreenRecording()">Start Screen Recording</button>
        <button onclick="stopScreenRecording()">Stop Screen Recording</button>
        <button onclick="analyzeBoard()">Analyze Board</button>
        <button onclick="suggestMove()">Suggest Checkmate Move</button>
        <button onclick="applySuggestedMove(0)" id="apply-move-0" disabled>Apply Move 1</button>
        <button onclick="applySuggestedMove(1)" id="apply-move-1" disabled>Apply Move 2</button>
        <button onclick="undoMove()">Undo Last Move</button>
    </div>
    <video id="screen-feed" autoplay playsinline></video>
    <input id="fen-input" type="text" placeholder="Enter FEN (e.g., rnbqkb1r/pppp1ppp/5n2/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 0 1)">
    <button onclick="loadFen()">Load FEN</button>
    <div id="move-suggestion"></div>
    <div id="status"></div>
    <div id="move-history"><strong>Move History:</strong> <span id="history-list">None</span></div>
    <div id="loading" class="loading">Analyzing for checkmate...</div>

    <!-- Chess.js for game logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <!-- Chessboard.js for board UI -->
    <script src="https://unpkg.com/chessboard-js@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <!-- Stockfish.js for move analysis -->
    <script src="https://cdn.jsdelivr.net/npm/stockfish@14.1.0/stockfish.js"></script>
    <script>
        // Initialize chess.js
        const game = new Chess();
        let board = null;
        let stockfish = null;
        let cvReady = false;
        let mediaRecorder = null;
        let stream = null;
        let moveHistory = [];
        let suggestedMoves = [];

        // Initialize chessboard.js
        const boardConfig = {
            draggable: true,
            position: 'start',
            onDrop: onDrop,
            onDragStart: onDragStart
        };
        board = Chessboard('chessboard', boardConfig);

        // Initialize Stockfish with multi-PV
        function initStockfish() {
            stockfish = new Worker('https://cdn.jsdelivr.net/npm/stockfish@14.1.0/stockfish.js');
            stockfish.onmessage = function(event) {
                const message = event.data;
                if (message.startsWith('info depth')) {
                    const pvMatch = message.match(/pv (\S+)/);
                    const scoreMatch = message.match(/score (cp|mate) (-?\d+)/);
                    if (pvMatch && scoreMatch) {
                        const move = pvMatch[1];
                        const scoreType = scoreMatch[1];
                        const scoreValue = parseInt(scoreMatch[2]);
                        const moveObj = {
                            from: move.substring(0, 2),
                            to: move.substring(2, 4),
                            promotion: move.length > 4 ? move[4] : 'q',
                            evaluation: scoreType === 'mate' ? `Mate in ${scoreValue}` : `${scoreValue / 100}`,
                            isMate: scoreType === 'mate'
                        };
                        const pvIndex = parseInt(message.match(/multipv (\d+)/)?.[1] || 1) - 1;
                        suggestedMoves[pvIndex] = moveObj;
                    }
                } else if (message.startsWith('bestmove')) {
                    displaySuggestedMoves();
                    document.getElementById('loading').style.display = 'none';
                }
            };
        }

        // Display suggested moves
        function displaySuggestedMoves() {
            let output = '<strong>Top Moves:</strong><ol>';
            suggestedMoves.forEach((move, index) => {
                if (move) {
                    output += `<li>${move.from}-${move.to} (Eval: ${move.evaluation}${move.isMate ? '!' : ''})</li>`;
                    document.getElementById(`apply-move-${index}`).disabled = false;
                }
            });
            output += '</ol>';
            document.getElementById('move-suggestion').innerHTML = output;
        }

        // Handle drag start
        function onDragStart(source, piece, position, orientation) {
            if (game.game_over()) return false;
            if (piece.search(/^b/) !== -1 && game.turn() === 'w') return false;
            if (piece.search(/^w/) !== -1 && game.turn() === 'b') return false;
        }

        // Handle drop (move piece)
        function onDrop(source, target) {
            const move = game.move({
                from: source,
                to: target,
                promotion: 'q'
            });
            if (move === null) return 'snapback';
            board.position(game.fen());
            updateStatus();
            updateMoveHistory();
        }

        // Update game status
        function updateStatus() {
            let status = '';
            if (game.in_checkmate()) {
                status = 'Game over, checkmate! ' + (game.turn() === 'b' ? 'White' : 'Black') + ' wins.';
            } else if (game.in_draw()) {
                status = 'Game over, draw!';
            } else {
                status = game.turn() === 'w' ? 'White to move' : 'Black to move';
                if (game.in_check()) {
                    status += ', check!';
                }
            }
            document.getElementById('status').innerText = status;
        }

        // Update move history
        function updateMoveHistory() {
            const moves = game.history({ verbose: true });
            moveHistory = moves.map(move => move.san);
            const historyText = moveHistory.length ? moveHistory.join(', ') : 'None';
            document.getElementById('history-list').innerText = historyText;
        }

        // Check screen recording support
        function isScreenRecordingSupported() {
            return !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia);
        }

        // Start screen recording
        function startScreenRecording() {
            if (!isScreenRecordingSupported()) {
                alert('Screen recording is not supported in this browser. Please use a desktop browser (e.g., Chrome, Edge) or enter FEN manually.');
                return;
            }
            const video = document.getElementById('screen-feed');
            video.style.display = 'block';
            navigator.mediaDevices.getDisplayMedia({ video: true })
                .then(displayStream => {
                    stream = displayStream;
                    video.srcObject = stream;
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.start();
                    mediaRecorder.ondataavailable = (event) => {
                        // Optional: Handle recorded data if needed
                    };
                })
                .catch(err => {
                    alert('Error accessing screen: ' + err.message + '. Try a different browser or enter FEN manually.');
                    video.style.display = 'none';
                });
        }

        // Stop screen recording
        function stopScreenRecording() {
            if (mediaRecorder && stream) {
                mediaRecorder.stop();
                stream.getTracks().forEach(track => track.stop());
                const video = document.getElementById('screen-feed');
                video.srcObject = null;
                video.style.display = 'none';
            }
        }

        // Placeholder for OpenCV.js readiness
        function onOpenCvReady() {
            cvReady = true;
            console.log('OpenCV.js is ready');
        }

        // Analyze board (screen capture placeholder)
        function analyzeBoard() {
            if (!cvReady) {
                alert('OpenCV.js is not loaded yet. Please wait.');
                return;
            }
            const video = document.getElementById('screen-feed');
            if (video.srcObject && !isScreenRecordingSupported()) {
                alert('Screen recording is active but not fully supported. Please enter FEN manually.');
                return;
            }
            // Placeholder for computer vision
            const fen = prompt('Computer vision not implemented. Enter FEN manually:', game.fen());
            if (fen && game.load(fen)) {
                board.position(fen);
                updateStatus();
                updateMoveHistory();
                document.getElementById('status').innerText = 'Board loaded from FEN: ' + fen;
            } else {
                alert('Invalid FEN string.');
            }
        }

        // Load FEN from input
        function loadFen() {
            const fen = document.getElementById('fen-input').value;
            if (fen && game.load(fen)) {
                board.position(fen);
                moveHistory = [];
                updateStatus();
                updateMoveHistory();
                document.getElementById('status').innerText = 'Board loaded from FEN: ' + fen;
            } else {
                alert('Invalid FEN string.');
            }
        }

        // Suggest next move with checkmate focus
        function suggestMove() {
            if (!stockfish) {
                initStockfish();
            }
            suggestedMoves = [];
            document.getElementById('loading').style.display = 'block';
            document.getElementById('move-suggestion').innerText = 'Analyzing for checkmate...';
            for (let i = 0; i < 2; i++) {
                document.getElementById(`apply-move-${i}`).disabled = true;
            }
            stockfish.postMessage('uci');
            stockfish.postMessage('setoption name MultiPV value 2');
            stockfish.postMessage('isready');
            stockfish.postMessage('position fen ' + game.fen());
            stockfish.postMessage('go depth 20');
        }

        // Apply suggested move
        function applySuggestedMove(index) {
            if (suggestedMoves[index]) {
                const move = game.move({
                    from: suggestedMoves[index].from,
                    to: suggestedMoves[index].to,
                    promotion: suggestedMoves[index].promotion
                });
                if (move) {
                    board.position(game.fen());
                    updateStatus();
                    updateMoveHistory();
                    for (let i = 0; i < 2; i++) {
                        document.getElementById(`apply-move-${i}`).disabled = true;
                    }
                }
            }
        }

        // Undo last move
        function undoMove() {
            game.undo();
            board.position(game.fen());
            updateStatus();
            updateMoveHistory();
            for (let i = 0; i < 2; i++) {
                document.getElementById(`apply-move-${i}`).disabled = true;
            }
        }

        // Initial status update
        updateStatus();
    </script>
</body>
</html>
