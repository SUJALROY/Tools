<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WinGo Game Analyzer</title>
    <style>
        :root {
            --primary: #1a237e;
            --secondary: #283593;
            --accent: #536dfe;
            --success: #4caf50;
            --danger: #f44336;
            --warning: #ff9800;
            --text: #ffffff;
            --bg-dark: #121212;
            --card-bg: rgba(30, 30, 46, 0.8);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--primary), var(--bg-dark));
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: var(--accent);
            text-shadow: 0 0 15px rgba(83, 109, 254, 0.5);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }
        
        .card h2 {
            margin-bottom: 20px;
            color: var(--accent);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .card h2 i {
            margin-right: 10px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 24px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button i {
            font-size: 1.1rem;
        }
        
        button:hover {
            background: #3d5afe;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.active {
            background: var(--success);
        }
        
        button.warning {
            background: var(--warning);
        }
        
        button.danger {
            background: var(--danger);
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .status.recording {
            background: rgba(244, 67, 54, 0.2);
            color: var(--danger);
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        
        .status.analyzing {
            background: rgba(255, 152, 0, 0.2);
            color: var(--warning);
            border: 1px solid rgba(255, 152, 0, 0.3);
        }
        
        .status.ready {
            background: rgba(76, 175, 80, 0.2);
            color: var(--success);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }
        
        .timer-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        
        .timer {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(83, 109, 254, 0.5);
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 12px;
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #3d5afe);
            width: 0%;
            transition: width 0.5s;
            border-radius: 10px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 10px 0;
            color: var(--accent);
        }
        
        .prediction {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .prediction-item {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin: 10px;
            min-width: 150px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .prediction-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 10px 0;
            padding: 10px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .prediction-big {
            color: var(--success);
            border: 2px solid var(--success);
        }
        
        .prediction-small {
            color: var(--accent);
            border: 2px solid var(--accent);
        }
        
        .prediction-red {
            color: var(--danger);
            border: 2px solid var(--danger);
        }
        
        .prediction-green {
            color: var(--success);
            border: 2px solid var(--success);
        }
        
        .prediction-violet {
            color: #9c27b0;
            border: 2px solid #9c27b0;
        }
        
        .history-container {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 10px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }
        
        .history-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .history-item:nth-child(even) {
            background: rgba(255, 255, 255, 0.03);
        }
        
        .chart-container {
            height: 300px;
            margin-top: 20px;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        .icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            margin-right: 8px;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 10px;
        }
        
        /* Animation for new predictions */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 0.5s ease-in-out;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-chart-line"></i> WinGo Game Analyzer</h1>
            <p class="subtitle">Real-time screen analysis and prediction system</p>
        </header>
        
        <div class="dashboard">
            <div class="card">
                <h2><i class="fas fa-sliders-h"></i> Control Panel</h2>
                <div class="controls">
                    <button id="startRecording">
                        <i class="fas fa-record-vinyl"></i> Start Recording
                    </button>
                    <button id="stopRecording" disabled>
                        <i class="fas fa-stop"></i> Stop Recording
                    </button>
                    <button id="analyzeMode" class="warning">
                        <i class="fas fa-brain"></i> Analysis: OFF
                    </button>
                    <button id="resetData" class="danger">
                        <i class="fas fa-trash"></i> Reset Data
                    </button>
                </div>
                
                <div class="status ready" id="statusIndicator">
                    <i class="fas fa-check-circle"></i> System Ready - Waiting to start recording
                </div>
                
                <div class="timer-container">
                    <div>Next Analysis In:</div>
                    <div class="timer" id="countdown">30</div>
                    <div class="progress-bar">
                        <div class="progress" id="analysisProgress"></div>
                    </div>
                </div>
                
                <div class="stats">
                    <div class="stat-item">
                        <div><i class="fas fa-history"></i> Games Analyzed</div>
                        <div class="stat-value" id="gamesAnalyzed">0</div>
                    </div>
                    <div class="stat-item">
                        <div><i class="fas fa-bullseye"></i> Accuracy</div>
                        <div class="stat-value" id="predictionAccuracy">0%</div>
                    </div>
                    <div class="stat-item">
                        <div><i class="fas fa-fire"></i> Current Streak</div>
                        <div class="stat-value" id="currentStreak">0</div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2><i class="fas fa-crystal-ball"></i> Prediction Results</h2>
                <div class="prediction">
                    <div class="prediction-item">
                        <div><i class="fas fa-balance-scale"></i> Next Big/Small</div>
                        <div class="prediction-value prediction-big" id="bigSmallPred">--</div>
                        <div>Confidence: <span id="bigSmallConf">--%</span></div>
                    </div>
                    <div class="prediction-item">
                        <div><i class="fas fa-palette"></i> Next Color</div>
                        <div class="prediction-value prediction-red" id="colorPred">--</div>
                        <div>Confidence: <span id="colorConf">--%</span></div>
                    </div>
                </div>
                
                <h2 style="margin-top: 30px;"><i class="fas fa-list-ol"></i> Recent History</h2>
                <div class="history-container" id="historyList">
                    <!-- History items will be added here dynamically -->
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2><i class="fas fa-chart-bar"></i> Analysis Chart</h2>
            <div class="chart-container">
                <canvas id="analysisChart"></canvas>
            </div>
        </div>
        
        <footer>
            <p>WinGo Game Analyzer &copy; 2023 | For educational purposes only</p>
            <p>This system analyzes screen recordings to detect patterns in the WinGo game</p>
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Initialize variables
        let isRecording = false;
        let isAnalyzing = false;
        let analysisMode = false;
        let gamesAnalyzed = 0;
        let correctPredictions = 0;
        let currentStreak = 0;
        let gameHistory = [];
        let countdownInterval;
        let countdownSeconds = 30;
        let lastPrediction = { bigSmall: null, color: null };
        
        // DOM Elements
        const startRecordingBtn = document.getElementById('startRecording');
        const stopRecordingBtn = document.getElementById('stopRecording');
        const analyzeModeBtn = document.getElementById('analyzeMode');
        const resetDataBtn = document.getElementById('resetData');
        const statusIndicator = document.getElementById('statusIndicator');
        const countdownElement = document.getElementById('countdown');
        const analysisProgress = document.getElementById('analysisProgress');
        const gamesAnalyzedElement = document.getElementById('gamesAnalyzed');
        const predictionAccuracyElement = document.getElementById('predictionAccuracy');
        const currentStreakElement = document.getElementById('currentStreak');
        const bigSmallPredElement = document.getElementById('bigSmallPred');
        const colorPredElement = document.getElementById('colorPred');
        const bigSmallConfElement = document.getElementById('bigSmallConf');
        const colorConfElement = document.getElementById('colorConf');
        const historyList = document.getElementById('historyList');
        
        // Initialize Chart
        const ctx = document.getElementById('analysisChart').getContext('2d');
        const analysisChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Big Probability',
                        data: [],
                        borderColor: '#4caf50',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        tension: 0.4,
                        fill: true,
                        borderWidth: 2
                    },
                    {
                        label: 'Small Probability',
                        data: [],
                        borderColor: '#536dfe',
                        backgroundColor: 'rgba(83, 109, 254, 0.1)',
                        tension: 0.4,
                        fill: true,
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            },
                            color: '#fff'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#fff'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#fff'
                        }
                    }
                }
            }
        });
        
        // Event Listeners
        startRecordingBtn.addEventListener('click', startRecording);
        stopRecordingBtn.addEventListener('click', stopRecording);
        analyzeModeBtn.addEventListener('click', toggleAnalysisMode);
        resetDataBtn.addEventListener('click', resetData);
        
        // Functions
        function startRecording() {
            isRecording = true;
            startRecordingBtn.disabled = true;
            stopRecordingBtn.disabled = false;
            statusIndicator.innerHTML = '<i class="fas fa-record-vinyl"></i> Recording in progress...';
            statusIndicator.className = 'status recording';
            
            // Start the game analysis simulation
            startCountdown();
            simulateGameAnalysis();
        }
        
        function stopRecording() {
            isRecording = false;
            startRecordingBtn.disabled = false;
            stopRecordingBtn.disabled = true;
            statusIndicator.innerHTML = '<i class="fas fa-check-circle"></i> Recording stopped';
            statusIndicator.className = 'status ready';
            
            clearInterval(countdownInterval);
            countdownElement.textContent = '30';
            analysisProgress.style.width = '0%';
        }
        
        function toggleAnalysisMode() {
            analysisMode = !analysisMode;
            analyzeModeBtn.innerHTML = analysisMode ? 
                '<i class="fas fa-brain"></i> Analysis: ON' : 
                '<i class="fas fa-brain"></i> Analysis: OFF';
            analyzeModeBtn.classList.toggle('active', analysisMode);
            
            if (analysisMode && isRecording) {
                statusIndicator.innerHTML = '<i class="fas fa-brain"></i> Analyzing game patterns...';
                statusIndicator.className = 'status analyzing';
            } else if (isRecording) {
                statusIndicator.innerHTML = '<i class="fas fa-record-vinyl"></i> Recording in progress...';
                statusIndicator.className = 'status recording';
            }
            
            // Generate initial prediction if analysis is turned on
            if (analysisMode && gameHistory.length > 0) {
                generatePrediction();
            }
        }
        
        function resetData() {
            gameHistory = [];
            gamesAnalyzed = 0;
            correctPredictions = 0;
            currentStreak = 0;
            updateStats();
            updateHistoryDisplay();
            analysisChart.data.labels = [];
            analysisChart.data.datasets[0].data = [];
            analysisChart.data.datasets[1].data = [];
            analysisChart.update();
            
            bigSmallPredElement.textContent = '--';
            colorPredElement.textContent = '--';
            bigSmallConfElement.textContent = '--%';
            colorConfElement.textContent = '--%';
            
            // Add pulse animation to reset
            document.querySelectorAll('.prediction-value').forEach(el => {
                el.classList.add('pulse');
                setTimeout(() => el.classList.remove('pulse'), 500);
            });
        }
        
        function startCountdown() {
            countdownSeconds = 30;
            updateCountdownDisplay();
            
            countdownInterval = setInterval(() => {
                countdownSeconds--;
                updateCountdownDisplay();
                
                // Update progress bar
                const progress = ((30 - countdownSeconds) / 30) * 100;
                analysisProgress.style.width = `${progress}%`;
                
                if (countdownSeconds <= 0) {
                    // Simulate new game result
                    simulateNewGame();
                    countdownSeconds = 30;
                }
            }, 1000);
        }
        
        function updateCountdownDisplay() {
            countdownElement.textContent = countdownSeconds;
        }
        
        function simulateGameAnalysis() {
            // In a real implementation, this would analyze the screen recording
            // For this demo, we'll simulate the analysis process
            
            if (isRecording && analysisMode) {
                // Simulate pattern detection
                setTimeout(() => {
                    if (isRecording && analysisMode) {
                        generatePrediction();
                    }
                }, 5000);
            }
        }
        
        function simulateNewGame() {
            // Generate random game result with some patterns to make it more realistic
            const result = generateRealisticResult();
            
            gameHistory.unshift(result);
            
            // Limit history to last 40 games as requested
            if (gameHistory.length > 40) {
                gameHistory = gameHistory.slice(0, 40);
            }
            
            gamesAnalyzed++;
            updateStats();
            updateHistoryDisplay();
            
            // Check if prediction was correct and auto-correct algorithm
            checkPredictionAccuracy(result);
            
            // Generate new prediction if analysis mode is on
            if (analysisMode) {
                generatePrediction();
            }
        }
        
        function generateRealisticResult() {
            // Create more realistic results with some patterns
            const colors = ['Red', 'Green', 'Violet'];
            let bigSmall, color;
            
            // Create some patterns in the results
            if (gameHistory.length > 5) {
                const lastFive = gameHistory.slice(0, 5);
                const bigCount = lastFive.filter(game => game.bigSmall === 'Big').length;
                const smallCount = lastFive.filter(game => game.bigSmall === 'Small').length;
                
                // If last 5 had more Big, increase chance of Small (and vice versa)
                if (bigCount >= 4) {
                    bigSmall = Math.random() < 0.7 ? 'Small' : 'Big';
                } else if (smallCount >= 4) {
                    bigSmall = Math.random() < 0.7 ? 'Big' : 'Small';
                } else {
                    bigSmall = Math.random() > 0.5 ? 'Big' : 'Small';
                }
                
                // Similar pattern for colors
                const redCount = lastFive.filter(game => game.color === 'Red').length;
                const greenCount = lastFive.filter(game => game.color === 'Green').length;
                const violetCount = lastFive.filter(game => game.color === 'Violet').length;
                
                if (redCount >= 3) {
                    color = Math.random() < 0.7 ? 
                        (greenCount <= violetCount ? 'Green' : 'Violet') : 'Red';
                } else if (greenCount >= 3) {
                    color = Math.random() < 0.7 ? 
                        (redCount <= violetCount ? 'Red' : 'Violet') : 'Green';
                } else if (violetCount >= 3) {
                    color = Math.random() < 0.7 ? 
                        (redCount <= greenCount ? 'Red' : 'Green') : 'Violet';
                } else {
                    color = colors[Math.floor(Math.random() * colors.length)];
                }
            } else {
                // Random results for first few games
                bigSmall = Math.random() > 0.5 ? 'Big' : 'Small';
                color = colors[Math.floor(Math.random() * colors.length)];
            }
            
            return {
                period: generatePeriodId(),
                bigSmall: bigSmall,
                color: color,
                timestamp: new Date()
            };
        }
        
        function generatePeriodId() {
            const now = new Date();
            return `20251022${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}${now.getMilliseconds().toString().padStart(3, '0')}`;
        }
        
        function generatePrediction() {
            // In a real implementation, this would use machine learning or statistical analysis
            // For this demo, we'll generate predictions with some bias based on recent history
            
            // Analyze recent trends in the last 40 games
            const recentGames = gameHistory.slice(0, 40);
            const bigCount = recentGames.filter(game => game.bigSmall === 'Big').length;
            const smallCount = recentGames.filter(game => game.bigSmall === 'Small').length;
            
            const redCount = recentGames.filter(game => game.color === 'Red').length;
            const greenCount = recentGames.filter(game => game.color === 'Green').length;
            const violetCount = recentGames.filter(game => game.color === 'Violet').length;
            
            // Generate predictions with bias toward less frequent outcomes
            const bigProbability = recentGames.length > 0 ? 
                Math.round((smallCount / recentGames.length) * 100) : 50;
            const smallProbability = 100 - bigProbability;
            
            // Color probabilities based on frequency
            const colorProbabilities = {
                Red: recentGames.length > 0 ? 
                    Math.round(((greenCount + violetCount) / (recentGames.length * 2)) * 100) : 33,
                Green: recentGames.length > 0 ? 
                    Math.round(((redCount + violetCount) / (recentGames.length * 2)) * 100) : 33,
                Violet: recentGames.length > 0 ? 
                    Math.round(((redCount + greenCount) / (recentGames.length * 2)) * 100) : 33
            };
            
            // Normalize color probabilities to sum to 100
            const totalColorProb = Object.values(colorProbabilities).reduce((a, b) => a + b, 0);
            if (totalColorProb > 0) {
                for (let color in colorProbabilities) {
                    colorProbabilities[color] = Math.round((colorProbabilities[color] / totalColorProb) * 100);
                }
            }
            
            // Determine predicted outcomes
            const predictedBigSmall = bigProbability > smallProbability ? 'Big' : 'Small';
            const predictedColor = Object.keys(colorProbabilities).reduce((a, b) => 
                colorProbabilities[a] > colorProbabilities[b] ? a : b
            );
            
            // Store prediction for accuracy checking
            lastPrediction = {
                bigSmall: predictedBigSmall,
                color: predictedColor
            };
            
            // Update UI with animations
            updatePredictionUI(predictedBigSmall, predictedColor, 
                              Math.max(bigProbability, smallProbability), 
                              colorProbabilities[predictedColor]);
            
            // Update chart
            updateChart(bigProbability, smallProbability);
        }
        
        function updatePredictionUI(bigSmall, color, bigSmallConf, colorConf) {
            // Add animation
            bigSmallPredElement.classList.add('pulse');
            colorPredElement.classList.add('pulse');
            
            // Update values
            bigSmallPredElement.textContent = bigSmall;
            colorPredElement.textContent = color;
            bigSmallConfElement.textContent = `${bigSmallConf}%`;
            colorConfElement.textContent = `${colorConf}%`;
            
            // Update classes for styling
            bigSmallPredElement.className = `prediction-value prediction-${bigSmall.toLowerCase()}`;
            colorPredElement.className = `prediction-value prediction-${color.toLowerCase()}`;
            
            // Remove animation after it completes
            setTimeout(() => {
                bigSmallPredElement.classList.remove('pulse');
                colorPredElement.classList.remove('pulse');
            }, 500);
        }
        
        function updateChart(bigProb, smallProb) {
            const now = new Date();
            const timeLabel = `${now.getMinutes()}:${now.getSeconds()}`;
            
            analysisChart.data.labels.push(timeLabel);
            analysisChart.data.datasets[0].data.push(bigProb);
            analysisChart.data.datasets[1].data.push(smallProb);
            
            // Keep only last 20 data points
            if (analysisChart.data.labels.length > 20) {
                analysisChart.data.labels.shift();
                analysisChart.data.datasets[0].data.shift();
                analysisChart.data.datasets[1].data.shift();
            }
            
            analysisChart.update();
        }
        
        function checkPredictionAccuracy(result) {
            // Check if the last prediction was correct
            if (lastPrediction.bigSmall) {
                const bigSmallCorrect = lastPrediction.bigSmall === result.bigSmall;
                const colorCorrect = lastPrediction.color === result.color;
                
                if (bigSmallCorrect) {
                    correctPredictions++;
                    currentStreak = Math.max(currentStreak, 0) + 1;
                } else if (lastPrediction.bigSmall) {
                    currentStreak = Math.min(currentStreak, 0) - 1;
                }
                
                updateStats();
                
                // Auto-correct algorithm if prediction was wrong
                if (!bigSmallCorrect && gameHistory.length > 10) {
                    // In a real implementation, we would adjust the prediction algorithm here
                    console.log("Prediction was incorrect, adjusting algorithm...");
                }
            }
        }
        
        function updateStats() {
            gamesAnalyzedElement.textContent = gamesAnalyzed;
            const accuracy = gamesAnalyzed > 0 ? Math.round((correctPredictions / gamesAnalyzed) * 100) : 0;
            predictionAccuracyElement.textContent = `${accuracy}%`;
            currentStreakElement.textContent = currentStreak;
            
            // Add animation to stats when they update
            gamesAnalyzedElement.classList.add('pulse');
            predictionAccuracyElement.classList.add('pulse');
            currentStreakElement.classList.add('pulse');
            
            setTimeout(() => {
                gamesAnalyzedElement.classList.remove('pulse');
                predictionAccuracyElement.classList.remove('pulse');
                currentStreakElement.classList.remove('pulse');
            }, 500);
        }
        
        function updateHistoryDisplay() {
            historyList.innerHTML = '';
            
            gameHistory.forEach((game, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                historyItem.innerHTML = `
                    <div>${game.period}</div>
                    <div>${game.bigSmall}</div>
                    <div>${game.color}</div>
                `;
                
                historyList.appendChild(historyItem);
            });
        }
        
        // Initialize with some sample history
        function initializeSampleData() {
            for (let i = 0; i < 15; i++) {
                const result = {
                    period: generatePeriodId(),
                    bigSmall: Math.random() > 0.5 ? 'Big' : 'Small',
                    color: ['Red', 'Green', 'Violet'][Math.floor(Math.random() * 3)],
                    timestamp: new Date(Date.now() - (i * 30000))
                };
                gameHistory.push(result);
            }
            gamesAnalyzed = 15;
            updateStats();
            updateHistoryDisplay();
        }
        
        // Initialize the application
        initializeSampleData();
    </script>
</body>
</html>
